<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="generator" content="Crystal Docs 1.6.2">
<meta name="crystal_docs.project_version" content="0.2.1">
<meta name="crystal_docs.project_name" content="base58">



<link href="css/style.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="js/doc.js"></script>

  <meta name="repository-name" content="base58">
  <title>base58 0.2.1</title>
  <script type="text/javascript">
  CrystalDocs.base_path = "";
  </script>
</head>
<body>

<svg class="hidden">
  <symbol id="octicon-link" viewBox="0 0 16 16">
    <path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path>
  </symbol>
</svg>
<div class="sidebar">
  <div class="sidebar-header">
    <div class="search-box">
      <input type="search" class="search-input" placeholder="Search..." spellcheck="false" aria-label="Search">
    </div>

    <div class="project-summary">
      <h1 class="project-name">
        <a href="index.html">
          base58
        </a>
      </h1>

      <span class="project-version">
        0.2.1
      </span>
    </div>
  </div>

  <div class="search-results hidden">
    <ul class="search-list"></ul>
  </div>

  <div class="types-list">
    <ul>
  
  <li class=" " data-id="base58/Array" data-name="array(t)">
      <a href="Array.html">Array</a>
      
    </li>
  
  <li class="parent " data-id="base58/Base58" data-name="base58">
      <a href="Base58.html">Base58</a>
      
        <ul>
  
  <li class="parent " data-id="base58/Base58/Alphabet" data-name="base58::alphabet">
      <a href="Base58/Alphabet.html">Alphabet</a>
      
        <ul>
  
  <li class=" " data-id="base58/Base58/Alphabet/Avalanche" data-name="base58::alphabet::avalanche">
      <a href="Base58/Alphabet/Avalanche.html">Avalanche</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/Alphabet/Bitcoin" data-name="base58::alphabet::bitcoin">
      <a href="Base58/Alphabet/Bitcoin.html">Bitcoin</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/Alphabet/Flickr" data-name="base58::alphabet::flickr">
      <a href="Base58/Alphabet/Flickr.html">Flickr</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/Alphabet/IPFS" data-name="base58::alphabet::ipfs">
      <a href="Base58/Alphabet/IPFS.html">IPFS</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/Alphabet/Monero" data-name="base58::alphabet::monero">
      <a href="Base58/Alphabet/Monero.html">Monero</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/Alphabet/Polkadot" data-name="base58::alphabet::polkadot">
      <a href="Base58/Alphabet/Polkadot.html">Polkadot</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/Alphabet/Ripple" data-name="base58::alphabet::ripple">
      <a href="Base58/Alphabet/Ripple.html">Ripple</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="base58/Base58/Base58Check" data-name="base58::base58check">
      <a href="Base58/Base58Check.html">Base58Check</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/CB58" data-name="base58::cb58">
      <a href="Base58/CB58.html">CB58</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/Check" data-name="base58::check">
      <a href="Base58/Check.html">Check</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/Checksum" data-name="base58::checksum">
      <a href="Base58/Checksum.html">Checksum</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/ChecksumMismatch" data-name="base58::checksummismatch">
      <a href="Base58/ChecksumMismatch.html">ChecksumMismatch</a>
      
    </li>
  
  <li class="parent " data-id="base58/Base58/Decoder" data-name="base58::decoder">
      <a href="Base58/Decoder.html">Decoder</a>
      
        <ul>
  
  <li class=" " data-id="base58/Base58/Decoder/Into" data-name="base58::decoder::into">
      <a href="Base58/Decoder/Into.html">Into</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="base58/Base58/Encoder" data-name="base58::encoder">
      <a href="Base58/Encoder.html">Encoder</a>
      
        <ul>
  
  <li class=" " data-id="base58/Base58/Encoder/Into" data-name="base58::encoder::into">
      <a href="Base58/Encoder/Into.html">Into</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="base58/Base58/PointerCollection" data-name="base58::pointercollection">
      <a href="Base58/PointerCollection.html">PointerCollection</a>
      
    </li>
  
  <li class=" " data-id="base58/Base58/SS58" data-name="base58::ss58">
      <a href="Base58/SS58.html">SS58</a>
      
    </li>
  
</ul>

      
    </li>
  
  <li class="parent " data-id="base58/Benchmark" data-name="benchmark">
      <a href="Benchmark.html">Benchmark</a>
      
        <ul>
  
  <li class="parent " data-id="base58/Benchmark/IPS" data-name="benchmark::ips">
      <a href="Benchmark/IPS.html">IPS</a>
      
        <ul>
  
  <li class=" " data-id="base58/Benchmark/IPS/Entry" data-name="benchmark::ips::entry">
      <a href="Benchmark/IPS/Entry.html">Entry</a>
      
    </li>
  
  <li class=" " data-id="base58/Benchmark/IPS/Job" data-name="benchmark::ips::job">
      <a href="Benchmark/IPS/Job.html">Job</a>
      
    </li>
  
</ul>

      
    </li>
  
</ul>

      
    </li>
  
  <li class=" " data-id="base58/StaticArray" data-name="staticarray(t, n)">
      <a href="StaticArray.html">StaticArray</a>
      
    </li>
  
  <li class=" " data-id="base58/String" data-name="string">
      <a href="String.html">String</a>
      
    </li>
  
  <li class=" " data-id="base58/StringBuffer" data-name="stringbuffer">
      <a href="StringBuffer.html">StringBuffer</a>
      
    </li>
  
</ul>

  </div>
</div>


<div class="main-content">
<p><img src="https://img.shields.io/github/actions/workflow/status/wyhaines/base58.cr/ci.yml?branch=main&amp;logo=GitHub" alt="Base58 CI" />
<a href="https://github.com/wyhaines/base58.cr/releases"><img src="https://img.shields.io/github/release/wyhaines/base58.cr.svg?style=for-the-badge" alt="GitHub release" /></a>
<img src="https://img.shields.io/github/commits-since/wyhaines/base58.cr/latest?style=for-the-badge" alt="GitHub commits since latest release (by SemVer)" /></p>
<h1><a id="base58" class="anchor" href="#base58">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>base58</h1>
<p>This library provides a very fast implementation of Base58 encoding and decoding for Crystal. This implementation supports all of the major Base58 alphabet variations, including Bitcoin, Flickr, Ripple, and Monero. In addition, it supports Monero's block based encoding approach, and it supports checksums using the Bitcoin Base58Check algorithm, the Avalanche CB58 algorithm, and the Polkadot SS58 algorithm along with encoding and decoding of Substrate addresses.</p>
<h2><a id="api-documentation" class="anchor" href="#api-documentation">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>API Documentation</h2>
<p>Full generated API documentation can be found at: <a href="https://wyhaines.github.io/base58.cr/">https://wyhaines.github.io/base58.cr/</a>.</p>
<h2><a id="benchmarks" class="anchor" href="#benchmarks">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Benchmarks</h2>
<p>A benchmark is provided in the <a href="https://github.com/wyhaines/base58.cr/tree/main/benchmark">benchmark/</a> directory. To build it and then run it:</p>
<pre><code class="language-bash">cd benchmark
shards build --release
bin/benchmark</code></pre>
<p>It will run a variety of encode/decode tests against both this package as well as against the other Crystal Base 58 packages. In addition if Rust is available on the system, it will run a small benchmark of Rust's fastest Base58 package, bs58, against some of the same data sets. A full run will look something like this:</p>
<p><img src="https://raw.githubusercontent.com/wyhaines/base58.cr/main/img/benchmark.jpg" alt="Benchmark" /></p>
<h2><a id="installation" class="anchor" href="#installation">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Installation</h2>
<ol>
<li>
<p>Add the dependency to your <code>shard.yml</code>:</p>
<pre><code class="language-yaml">dependencies:
  base58:
    github: wyhaines/base58</code></pre>
</li>
<li>
<p>Run <code>shards install</code></p>
</li>
</ol>
<h2><a id="usage" class="anchor" href="#usage">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Usage</h2>
<pre><code class="language-crystal"><span class="k">require</span> <span class="s">&quot;base58&quot;</span></code></pre>
<p>Basic usage is via two methods, <code>Base58.encode</code> and <code>Base58.decode</code>. These methods can take a variety of input types, and can decode/encode into a variety of output types -- <code>String.class</code>, <code>Slice(UInt8).class</code>, <code><a href="StaticArray.html">StaticArray</a>(UInt8, N).class</code>, <code><a href="Array.html">Array</a>(UInt8).class</code>, <code><a href="Array.html">Array</a>(Char).class</code>, <code>StringBuffer.class</code>, <code>Pointer(UInt8).class</code>, <code><a href="String.html">String</a></code>, <code>Slice(UInt8)</code>, <code><a href="StaticArray.html">StaticArray</a>(UInt8, N)</code>, <code><a href="Array.html">Array</a>(UInt8)</code>, <code><a href="Array.html">Array</a>(Char)</code>, <code><a href="StringBuffer.html">StringBuffer</a></code>, and <code>Pointer(UInt8)</code>.</p>
<pre><code class="language-crystal"><span class="t">Base58</span>.encode(<span class="s">&quot;Hello, World!&quot;</span>)</code></pre>
<p>The default return type is <code>String.class</code>, which returns a new instance of <code><a href="String.html">String</a></code>. Thus, this example will return the Base58 version of <code>Hello, World!</code> as a <code><a href="String.html">String</a></code>.</p>
<p>If you wanted that value returned as a <code>Slice(UInt8)</code> instead:</p>
<pre><code class="language-crystal"><span class="t">Base58</span>.encode(<span class="s">&quot;Hello, World!&quot;</span>, into: <span class="t">Slice</span>(<span class="t">UInt8</span>))</code></pre>
<p>If you have an existing <code>Slice(UInt8)</code> that you are using as a reusable buffer, you can use that, too:</p>
<pre><code class="language-crystal">buffer <span class="o">=</span> <span class="t">Slice</span>(<span class="t">UInt8</span>).new(<span class="n">100</span>)
<span class="t">Base58</span>.encode(<span class="s">&quot;Hello, World!&quot;</span>, into: buffer)</code></pre>
<p>Or maybe you have a <code>Slice(UInt8)</code> of bytes to encode, and you want to encode them into a <code><a href="StringBuffer.html">StringBuffer</a></code>.</p>
<pre><code class="language-crystal">buffer <span class="o">=</span> <span class="t">Slice</span>(<span class="t">UInt8</span>).new(<span class="n">100</span>)
<span class="c"># Stuff happens to get data into `buffer`.</span>
<span class="t">Base58</span>.encode(buffer, into: <span class="t">StringBuffer</span>)</code></pre>
<p>Decoding works in the same way, with the same flexibility.</p>
<p>So, perhaps you have received a Base58 encoded piece of data into a StringBuffer, and want to decode it into another, already-existing StringBuffer:</p>
<pre><code class="language-crystal">decoded_buffer <span class="o">=</span> <span class="t">StringBuffer</span>.new(<span class="n">256</span>)

<span class="c"># receive data into `recv_buffer`</span>

<span class="t">Base58</span>.decode(recv_buffer, into: decoded_buffer)</code></pre>
<h3><a id="alphabets" class="anchor" href="#alphabets">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Alphabets</h3>
<p>There are four supported alphabets, the Bitcoin alphabet, the Flickr alphabet, the Ripple alphabet, and the Monero alphabet. Of these, all are encoded and decoded the same except for the Monero alphabet, which for encoding operates on blocks of 8 bytes, padding to 11 bytes, except for the final block. For decoding, it operates on blocks of 11 bytes, returning 8 bytes of decoded data, except for the final block which can be smaller. For the other three alphabets, the final size of the encoded data is variable, but the Monero encoding ensures a consistent final size. Thus, Monero addresses, which are 69 bytes of data, always encode to 95 byte Base58 strings.</p>
<p>The bitcoin alphabet is the default. To use another alphabet, pass the class of the alphabet as an argument:</p>
<pre><code class="language-crystal"><span class="t">Base58</span>.encode(<span class="s">&quot;Hello, World!&quot;</span>, into: <span class="t">Slice</span>(<span class="t">UInt8</span>), alphabet: <span class="t">Base58</span><span class="t">::</span><span class="t">Alphabet</span><span class="t">::</span><span class="t">Monero</span>)</code></pre>
<p>Alphabets support both forward and inverse lookup. Thus, the following will return the original character:</p>
<pre><code class="language-crystal"><span class="t">Base58</span><span class="t">::</span><span class="t">Alphabet</span><span class="t">::</span><span class="t">Bitcoin</span>.inverse(<span class="t">Base58</span><span class="t">::</span><span class="t">Alphabet</span><span class="t">::</span><span class="t">Bitcoin</span>[<span class="s">&#39;a&#39;</span>.ord]).chr</code></pre>
<p>The alphabets encode the ASCII codes for the characters, since Base58 alphabets all utilize single byte ASCII characters. Thus, to lookup a <code>Char</code>, it has to be cast to a <code>UInt8</code> first.</p>
<p>Nil-returning variants of both forward and backward lookups are also supported:</p>
<pre><code class="language-crystal"><span class="t">Base58</span><span class="t">::</span><span class="t">Alphabet</span><span class="t">::</span><span class="t">Bitcoin</span>.inverse?(<span class="t">Base58</span><span class="t">::</span><span class="t">Alphabet</span><span class="t">::</span><span class="t">Bitcoin</span>[some_UTF8_character]?)</code></pre>
<p>If the character is not found in the alphabet, the forward lookup, via <code>#[]</code>, will return an exception, but if called via <code>#[]?</code>, <code>nil</code> will be returned if it is not found. The inverse lookup returns a <code>0</code> for any ASCII character code that is not found in the alphabet when called with <code>#inverse</code>, and an exception for any non-ASCII character code. When called with <code>inverse?</code>, it returns nil for any code that is not found in the alphabet, ASCII or not.</p>
<h3><a id="checksumming" class="anchor" href="#checksumming">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Checksumming</h3>
<p>In addition to the various alphabets, three different checksum algorithms are supported, Base58Check, CB58, and SS58. To use a checksum, pass an instance of <code><a href="Base58/Check.html">Base58::Check</a></code> into the <code>encode</code> or <code>decode</code> methods:</p>
<pre><code class="language-crystal">base58check_data <span class="o">=</span> <span class="t">Base58</span>.encode(
  <span class="s">&quot;Hello, World!&quot;</span>,
  into: <span class="t">Slice</span>(<span class="t">UInt8</span>),
  check: <span class="t">Base58</span><span class="t">::</span><span class="t">Check</span>.new)</code></pre>
<p>Without parameters, an instance of <code>Check</code> specifies Base58Check encoding with a prefix of <code>0x31</code> (<code>1</code>). To specify a different prefix, pass is as the first argument to <code>new</code>, or via a named argument, <code>prefix</code>.</p>
<pre><code class="language-crystal">base58check_data <span class="o">=</span> <span class="t">Base58</span>.encode(
  <span class="s">&quot;Hello, World!&quot;</span>,
  into: <span class="t">StringBuffer</span>,
  check: <span class="t">Base58</span><span class="t">::</span><span class="t">Check</span>.new(<span class="n">0x32</span>))
)</code></pre>
<pre><code class="language-crystal">base58check_data <span class="o">=</span> <span class="t">Base58</span>.encode(
  <span class="s">&quot;Hello, World!&quot;</span>,
  into: <span class="t">StringBuffer</span>,
  check: <span class="t">Base58</span><span class="t">::</span><span class="t">Check</span>.new(prefix: <span class="n">0x32</span>))
)</code></pre>
<p>To specify a different checksum algorithm, use the <code>type</code> named argument:</p>
<pre><code class="language-crystal">cb58_data <span class="o">=</span> <span class="t">Base58</span>.encode(
  <span class="s">&quot;Hello, World!&quot;</span>,
  into: <span class="t">StringBuffer</span>,
  check: <span class="t">Base58</span><span class="t">::</span><span class="t">Check</span>.new(<span class="k">type</span>: <span class="t">Base58</span><span class="t">::</span><span class="t">Check</span><span class="t">::</span><span class="t">CB58</span>))
)</code></pre>
<p>The <a href="https://docs.substrate.io/reference/address-formats/">SS58 checksum algorithm for Substrate</a> has more moving parts than the Base58Check or the CB58 algorithms, with a variable prefix, variable checksum length, and a prefix that is applied to the data to be checksummed before checksumming. Thus, using it takes a few more parameters:</p>
<pre><code class="language-crystal">ss58_data <span class="o">=</span> <span class="t">Base58</span>.encode(
  <span class="s">&quot;Hello, World!&quot;</span>,
  into: <span class="t">StringBuffer</span>,
  check: <span class="t">Base58</span><span class="t">::</span><span class="t">Check</span>.new(
    <span class="k">type</span>: <span class="n">:SS58</span>,
    prefix: <span class="s">&quot;*&quot;</span>,
    checksum_length: <span class="n">2</span>,
    checksum_prefix: <span class="s">&quot;SS58PRE&quot;</span>))
)</code></pre>
<p>If you look at the <a href="https://docs.substrate.io/reference/address-formats/">Substrate Address Format Specification</a>, you will see that encoding and decoding Substrate addresses with SS58 is a bit more complicated than just setting a prefix and running a hashing algorithm. The <code><a href="Base58/SS58.html">Base58::SS58</a></code> class provides convenience methods for encoding and decoding Substrate addresses, and it is recommended that you are using this library to interact with Substrate, you should use those methods instead of the <code>Base58.encode</code> and <code>Base58.decode</code> methods directly.</p>
<pre><code class="language-crystal">substrate_address <span class="o">=</span> <span class="t">Base58</span><span class="t">::</span><span class="t">SS58</span>.encode(<span class="s">&quot;d172a74cda4c865912c32ba0a80a57ae69abae410e5ccb59dee84e2f4432db4f&quot;</span>.hexbytes)</code></pre>
<p>Just like the basic <code>encode</code>/<code>decode</code> methods, the <code>SS58</code> variants support all of the same input and output types, and in addition, they support a <code>format</code> argument which specifies the format prefix, as defined in the above URL.</p>
<pre><code class="language-crystal">substrate_address <span class="o">=</span> <span class="t">Base58</span><span class="t">::</span><span class="t">SS58</span>.encode(
  <span class="s">&quot;d172a74cda4c865912c32ba0a80a57ae69abae410e5ccb59dee84e2f4432db4f&quot;</span>.hexbytes,
  into: <span class="t">Slice</span>(<span class="t">UInt8</span>),
  format: <span class="n">255</span>)</code></pre>
<p>Exceptions will be raised if an invalid format is provided, or if the data to be encoded is not a valid length for SS58 encoding.</p>
<p>The same invocation syntax is used when decoding encoded Substrate addresses.</p>
<pre><code class="language-crystal">encoded_address <span class="o">=</span> <span class="t">Base58</span><span class="t">::</span><span class="t">SS58</span>.encode(
  <span class="s">&quot;d172a74cda4c865912c32ba0a80a57ae69abae410e5ccb59dee84e2f4432db4f&quot;</span>.hexbytes,
  into: <span class="t">Slice</span>(<span class="t">UInt8</span>),
  format: <span class="n">255</span>)

decoded_address <span class="o">=</span> <span class="t">Base58</span><span class="t">::</span><span class="t">SS58</span>.decode(encoded_address)</code></pre>
<p>If the <code>format</code> argument is provided when decoding, it will be used to guarantee that the encoded address was encoded with the same format. An exception will be raised if the format does not match.</p>
<h3><a id="alternative-method-chaining-based-syntax." class="anchor" href="#alternative-method-chaining-based-syntax.">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Alternative, method chaining based syntax.</h3>
<p>There is an alternative syntax that is supported, though it should be considered to be an experiment. I don't know if I will keep this support as it needs some work to be really transparently usable. Right now <code>.as(TYPE)</code> annotations are needed because I have not fleshed out the implementation. If you feel inspired, and want to offer a PR to help make this better, I would be appreciative.</p>
<pre><code class="language-crystal">Base58::Encoder.into(String).encode(&quot;some text&quot;).as(String)

buffer = StringBuffer.new(256)
Base58::Decoder.into(buffer).decode(some_encoded_thing)

as_slice = Base58::Encoder.into(Slice(UInt8)).encode(&quot;some text).as(Slice(UInt8))</code></pre>
<h2><a id="crystal-extensions-and-other-goodies" class="anchor" href="#crystal-extensions-and-other-goodies">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Crystal Extensions and Other Goodies</h2>
<p>There are several extensions to Crystal that are bundled into this library pending submitting them as pull requests to Crystal itself.</p>
<h3><a id="char.static-array" class="anchor" href="#char.static-array">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Char.static_array</h3>
<p>The number types, such as UInt8, have a macro defined on them to facilitate the creation of a prepopulated StaticArray, <a href="https://crystal-lang.org/api/1.7.1/Number.html#static_array(*nums)-macro">static_array</a>. This extension adds the same macro to <code>Char</code>.</p>
<h3><a id="sliceto-unsafe" class="anchor" href="#sliceto-unsafe">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Slice#to_unsafe</h3>
<p>This adds a method to a <code>Slice</code> that returns a pointer to the first element of the slice.</p>
<h3><a id="string.static-array" class="anchor" href="#string.static-array">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>String.static_array</h3>
<p>The number types, such as UInt8, have a macro defined on them to facilitate the creation of a prepopulated StaticArray, <a href="https://crystal-lang.org/api/1.7.1/Number.html#static_array(*nums)-macro">static_array</a>. This extension adds the same macro to <code><a href="String.html">String</a></code>.</p>
<h3><a id="stringnewstring-string" class="anchor" href="#stringnewstring-string">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>String#new(string : String)</h3>
<p>This creates a dynamically allocated string, even when passed a string literal. While this is not something that one normally wants, there are times when you want to ensure that a <em>new</em> object, with a new section of memory backing it, is created for a given string literal. This will guarantee that.</p>
<h3><a id="stringnewsize-int" class="anchor" href="#stringnewsize-int">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>String#new(size : Int)</h3>
<p>This is a simple helper that creates an empty string in the requested size. This may seem
useless, as Crystal Strings are immutable. However, this can be useful if you want to say &quot;Not today!&quot; to the god of Immutability and mutate an immutable String as a very very handy buffer with a maximum fixed size.</p>
<h3><a id="string-buffer" class="anchor" href="#string-buffer">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>StringBuffer</h3>
<p>Imagine that you want to take some data that is stuffed into a piece of memory, and you want to be able to treat it as a String, doing all the normal String things. But you
want it to be as fast as possible because you are going to be doing this a lot.</p>
<p>Say &quot;Hello&quot; to StringBuffer. It is a thin wrapper around a String, and it forwards any unknown method calls to the String that it carries in an instance variable, so it generally behaves like a String. However, it defines a <code>#mutate</code> method that can be called to <em>change</em> the value of the underlying String, with some limits.</p>
<p>Nothing can be stored in a StringBuffer that is larger than the original capacity of the StringBuffer. However, anything the same size or smaller can be inserted into the String, replacing the previous contents.</p>
<h2><a id="development" class="anchor" href="#development">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Development</h2>
<p>The goals are to have a clear, capable, and easy to use API that sits above an implementation that is the fastest available for Crystal, and that is performance competitive with Rust.</p>
<p>Internals cleanups or optimizations are welcome, as are any bug fixes or improved documentation.</p>
<h2><a id="contributing" class="anchor" href="#contributing">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Contributing</h2>
<ol>
<li>Fork it (<a href="https://github.com/wyhaines/base58/fork">https://github.com/wyhaines/base58/fork</a>)</li>
<li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li>
<li>Commit your changes (<code>git commit -am 'Add some feature'</code>)</li>
<li>Push to the branch (<code>git push origin my-new-feature</code>)</li>
<li>Create a new Pull Request</li>
</ol>
<h2><a id="contributors" class="anchor" href="#contributors">
  <svg class="octicon-link" aria-hidden="true">
    <use href="#octicon-link"/>
  </svg>
</a>Contributors</h2>
<ul>
<li><a href="https://github.com/wyhaines">Kirk Haines</a> - creator and maintainer</li>
</ul>
<p><img src="https://img.shields.io/github/languages/code-size/wyhaines/base58.cr?style=for-the-badge" alt="GitHub code size in bytes" />
<img src="https://img.shields.io/github/issues/wyhaines/base58.cr?style=for-the-badge" alt="GitHub issues" /></p>
</div>
</body>
</html>
